
<!-- saved from url=(0066)http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Quake Specs v3.4</title>
<link rev="MADE" href="mailto:Olivier.Montanuy@wanadoo.fr">
</head>  
<body bgcolor="#FFFFFF">
<h1><font color="#007F00">4. <a name="CBSP0">Level Map Models</a></font></h1>
<h2><font color="#4F1F00">4.1 <a name="CBSPG">Description of .BSP Files</a></font></h2>

<h3>4.1.1 General description of level BSP Maps</h3>

<p>The BSP maps are meant to be generated automatically. They are described
here only for the purpose of helpin you write a BSP generation tool.
If you are only interested in building Quake editors, please read the 
description of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_2.htm#CMFMF" target="content">Level Maps</a> instead.</p>

<p>The level BSP maps are stored in files with extension <tt>.BSP</tt> (for
Binary Space Partition Tree).  Those files need not necessarily contain
level maps, they can also contain the definition of any entity that is
not supposed to be modified during game play.</p>

<p>Since a BSP based model requires the calculation of a BSP tree, and
this calculation is tedious, these models are not used to store
definitions of monsters, players, or anything that can change shape
during game play.  But you could use them for a model of a big rock,
because that rock isn't gonna be modified...</p>

<p>Moreover, there are no frames associated to a BSP based model,
contrary to what happens for Alias models: it's just one single big
frame.  So you cannot animate them.</p>

<h3>4.1.2 Description of the contents of .BSP files</h3>

<p>The .BSP files contain all the information that is needed to
display a level correctly, for the obvious reason that those files are
meant to be distributed individually, or associated in multi-level
maps without causing trouble.  In DOOM, you had to take care that all
the needed textures were available.  Now, the textures are in the level
itself.</p>

<p>One disadvantage of that format is that, contrary to DOOM, you
cannot have a single set of textures for all your levels, or re-use
textures in another level.  Now guess why Quake will come on
CD-ROM.</p>


<p>Here are the contents of levels:
</p><ol>
<li> A list of entities that are present in the level.
</li><li> A description of the level map, in term of faces, edges, vertices,
    and textures on the faces. Actually, there might be more faces
         than really needed, because of the BSP tree that splits them.
</li><li> Some <b>enormous</b> amount of data to accelerate the rendering
   of levels, and which must be calculated off-line: a set of planes,
        models, BSP nodes, clip nodes, BSP leaves,
        visibility lists, and edge lists, face lists.
</li></ol>
<p></p>

<p>The format of level is pretty complicated, don't be disappointed if
you don't understand everything on first try.  Maybe you can imagine
how hard it has been to hack it out of the BSP map.</p>



<hr>

<h2><font color="#4F1F00">4.2 <a name="CBSPF">The Format of BSP files</a></font></h2>

<p>Beware: the description below is valid only for the version <tt>0x1C</tt>
of the BSP file format, used in Quake Shareware version, 22 June 96.
Previous version of Quake used different formats. Future versions might 
differ again.</p>

<p>A BSP file starts with some sort of directory, of fixed size.  As a
matter of fact, the entries in a BSP file are always at the same place
in the directory.</p>

<p>Here is the description of one directory entry:
</p><pre>typedef struct                 // A Directory entry
{ long  offset;                // Offset to entry, in bytes, from start of file
  long  size;                  // Size of entry in file, in bytes
} dentry_t;
</pre>
Here is the BSP header itself, made of a version tag, and 15 entries:
<pre>typedef struct                 // The BSP file header
{ long  version;               // Model version, must be <tt>0x17</tt> (23).
  dentry_t entities;           // List of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL0" target="content">Entities</a>.
  dentry_t planes;             // Map <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL1" target="content">Planes</a>.
                               // numplanes = size/sizeof(plane_t)
  dentry_t miptex;             // Wall <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL2" target="content">Textures</a>.
  dentry_t vertices;           // Map <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL3" target="content">Vertices</a>.
                               // numvertices = size/sizeof(vertex_t)
  dentry_t visilist;           // Leaves <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL4" target="content">Visibility</a> lists.
  dentry_t nodes;              // <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL5" target="content">BSP Nodes</a>.
                               // numnodes = size/sizeof(node_t)
  dentry_t texinfo;            // <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">Texture Info</a> for faces.
                               // numtexinfo = size/sizeof(texinfo_t)
  dentry_t faces;              // <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">Faces</a> of each surface.
                               // numfaces = size/sizeof(face_t)
  dentry_t lightmaps;          // Wall <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL8" target="content">Light Maps</a>.
  dentry_t clipnodes;          // <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL9" target="content">clip nodes</a>, for Models.
                               // numclips = size/sizeof(clipnode_t)
  dentry_t leaves;             // <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">BSP Leaves</a>.
                               // numlaves = size/sizeof(leaf_t)
  dentry_t lface;              // List of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLB" target="content">Faces</a>.
  dentry_t edges;              // <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLC" target="content">Edges</a> of faces.
                               // numedges = Size/sizeof(edge_t)
  dentry_t ledges;             // List of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLD" target="content">Edges</a>.
  dentry_t models;             // List of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLE" target="content">Models</a>.
                               // nummodels = Size/sizeof(model_t)
} dheader_t;
</pre><p></p>

<p>All the offsets are counted from the start of the BSP files.  The
size can be 0, if the entry is not present.  It must not be
negative.</p>

<h3><a name="BLM">Basic data types</a></h3>

<p>Before we start with the level entry structure, you will need to
understand the following data types:
</p><pre>typedef float scalar_t;        // Scalar value,

typedef struct                 // Vector or Position
{ scalar_t x;                  // horizontal
  scalar_t y;                  // horizontal
  scalar_t z;                  // vertical
} vec3_t;

typedef struct                 // Bounding Box, Float values
{ vec3_t   min;                // minimum values of X,Y,Z
  vec3_t   max;                // maximum values of X,Y,Z
} boundbox_t;

typedef struct                 // Bounding Box, Short values
{ short   min;                 // minimum values of X,Y,Z
  short   max;                 // maximum values of X,Y,Z
} bboxshort_t;
</pre><p></p>

<p><tt>scalar_t</tt> is a scalar value, that is used to represent X,Y,Z
coordinates, or distances.  It is a 32bit, single precision floating
point number, and it can be expected that in later version it will be
replaced by some fixed point number, as is typical in DOS games
(because the floating point unit of Intels just amazingly sucks).</p>

<p><tt>vec3_t</tt> is a 3D vector, that is used to represent either 3D
position in space, or vectors normal to planes.  Usually, 3D positions
in space will be integer values, though they are coded in floating
point.  Maybe a hint that the final engine will work only with integer
of fixed point values, like DOOM did.</p>

<p><tt>boundbox_t</tt> is a set of two vec3_t, that represents a
bounding box in 3D space.  The first vec3_t stores the minimum values,
the second one stores the maximum values.  These bounding boxes, though
less elegant than a center point and a distance, allow for greater
processing speed.</p>


<p><tt>bboxshort_t</tt> is a set of six short integer, that represent 
a condensed form of boundbox_t, the ordinary bounding box.</p>


<hr>


<h2><font color="#4F1F00">4.3 <a name="CBSPL">Level layout definition</a></font></h2>

<p>The basic level entries are those that define the geometrical
structure of the level; i.e. those are the only ones a level editor
should ever bother about.</p>

<p>Actually, this is not totally true, because those entries are
intricately related to the BSP tree format, so an intermediate format
shall be used, before calculating the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#CBSPN" target="content">BSP tree</a>
and the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#CBSPC" target="content">pre-calculated</a> entries.</p>


<h3>4.3.1 <a name="BLE">The Definitions of Models</a></h3>

<p><i>The name Model refers here to either a big zone, the level, or
smaller independent parts inside that zone, like the grid bars on
level TEST1, that open with a push on the switch.</i></p>

<p>The level map is divided in one or more Models, which are
independent areas, roughly bounded by two sets of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL9" target="content">Clip Nodes</a>,
and organised internally around a <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL5" target="content">BSP Tree</a>, that
contains the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">BSP Leaves</a>, which are the actual areas
where entities can be found (like the sectors in DOOM).</p>

<p></p><pre>typedef struct
{ boundbox_t bound;            // The bounding box of the Model
  vec3_t origin;               // origin of model, usually (0,0,0)
  long node_id0;               // index of first <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL5" target="content">BSP node</a>
  long node_id1;               // index of the first <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL9" target="content">Clip node</a>
  long node_id2;               // index of the second <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL9" target="content">Clip node</a>
  long node_id3;               // usually zero
  long numleafs;               // number of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">BSP leaves</a>
  long face_id;                // index of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">Faces</a>
  long face_num;               // number of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">Faces</a>
} model_t;
</pre><p></p>

<h4>About the Models</h4>

<p>The first model is the whole level itself.
The other models, smaller, represent door, switches, bars, that might
move around the level. </p>

<p>A typical BSP model is only made of one single model, and only the
level maps may eventually need more than one model.<br>

</p><h4>About the different fields</h4>

<p>The <tt>numleafs</tt> field is the number of leaves in the BSP tree.
It is used to determine how much room each  <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL4" target="content">visilists</a> 
requires when decompressed (better not put a wrong number there).</p>

<p>The <tt>node_id</tt> field is an index to the first node of the
BSP tree that splits the model. 
</p>

<p>The <tt>bnode_id</tt> and <tt>bnode_id2</tt> field is an index to the 
first node of two BSP tree that are used for early collision detection.
There used to be only one of these trees. The purpose of the second
tree is unknown (maybe it's not for collision detection after all).
</p>

<p>The <tt>face_id</tt> and <tt>face_num</tt> fields refer to
all the consecutive faces in the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">face list</a>
that belong to a given model.</p>






<h3>4.3.2 <a name="BL3">List of Vertices</a></h3>

<p>The vertices definitions are used for <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLC" target="content">Edges</a>,
which are part of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">faces</a>.</p>

<p>The order of vertices in the list is irrelevant.
</p><pre>typedef struct
{ float X;                    // X,Y,Z coordinates of the vertex
  float Y;                    // usually some integer value
  float Z;                    // but coded in floating point
} vertex_t;
</pre><p></p>

<p>The vertices are only used for texture mapping.</p>

<p>There must be only one given vertex definition, for any point in 3D
space.</p>


<h3>4.3.3 <a name="BLC">The Edges</a></h3>

<p>This structure stores a list of pairs of indexes of vertices, each
pair defining an edge of a face.  That edge will generally be used
by more than one face (two or three is typical).</p>

<p>Edges are referenced in <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLD" target="content">List of edges</a>, that
represent the actual list of edges contained in each 
<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">face</a>. The edges are not directly referenced
in faces, otherwise the face structure could not have
a fixed size.</p>


<p></p><pre>typedef struct
{ u_short vertex0;             // index of the start <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL3" target="content">vertex</a>
                               //  must be in [0,numvertices[
  u_short vertex1;             // index of the end <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL3" target="content">vertex</a>
                               //  must be in [0,numvertices[
} edge_t;
</pre><p></p>

<p>Note that the first edge in the list is never used: as a matter of
fact, the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLD" target="content">List of Edges</a> uses positive or negative
numbers to indicate the edge sense, so number zero would be unsuitable.</p>



<h3>4.3.4 <a name="BL6">The Texture Informations</a></h3>

<p>The texture informations define how the textures are rendred on the
faces (i.e. the Wall, Floors, Ceilings, Sky, and Water areas).</p>

<p>Since those surfaces can be of complex shape, they are split in simple
convex <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">Faces</a>. But then, all those faces have a reference
to the same texture information.</p>

<p></p><pre>typedef struct
{ vec3_t   vectorS;            // S vector, horizontal in texture space)
  scalar_t distS;              // horizontal offset in texture space
  vec3_t   vectorT;            // T vector, vertical in texture space
  scalar_t distT;              // vertical offset in texture space
  u_long   texture_id;         // Index of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL2" target="content">Mip Texture</a>
                               //           must be in [0,numtex[
  u_long   animated;           // 0 for ordinary textures, 1 for water 
} surface_t;
</pre><p></p>


<h4>Texture orientation</h4>

<p>The orientation of the texture, on the face, is defined
by two vectors <tt>S</tt> and <tt>T</tt>) and two offsets along these 
vectors, <tt>distS</tt> and <tt>distT</tt>.<br>
See the explanation of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">Texture Mapping</a> below.</p>

<p>The animated field is just a boolean that is set to 1 when
the texture is to be used with a swirling animated texture, like water,
slime or lava. If it is not set to 1 with those textures, the game
crashes, complaining that surface extent is invalid.</p> 

<h4>Mips mapping</h4>

<p>The textures are rendered by using Mip Mapping: depending on the
distance from the face to the player, a different texture is used
for texture mapping, so as to reduce aliasing.</p>

<p>Since the Mip Mapping uses distance as a trigger, the bounding box
of all face vertices (i.e. the face extent) must be <em>smaller
than 256</em>, for any coordinate.  Otherwise it would not be possible
to select a Mip Mapping valid for all the texture.</p>

<p>Once the right texture is chosen, the face is rendered as an
ordinary texture-mapped convex face.</p>

<h4>Texture names</h4>

<p>The Mip texture are referenced by <tt>texture_id</tt>, so that
more than 256 textures can be used in a level. But it is expected that
the more texture you use, the slower the game will be, so do not
use more than 64 without very good reasons.</p>

<p>Depending on the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#CBSPI" target="content">name of the texture</a>, a 
face will look like a sky, or a wall or floor (that can eventually be 
animated).</p>




<h3>4.3.5 <a name="BL7">The Face</a></h3>

<p>The face are convex polygons that cover the original surfaces
(convex polygons are more convenient for 3D rendering, especially
in hardware).</p>

<pre>typedef struct  
{ u_short plane_id;            // The <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL1" target="content">plane</a> in which the face lies
                               //           must be in [0,numplanes[ 
  u_short side;                // 0 if in front of the plane, 1 if behind the plane
  long ledge_id;               // first edge in the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLD" target="content">List of edges</a>
                               //           must be in [0,numledges[
  u_short ledge_num;           // number of edges in the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLD" target="content">List of edges</a>
  u_short texinfo_id;          // index of the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">Texture info</a> the face is part of
                               //           must be in [0,numtexinfos[ 
  u_char typelight;            // type of lighting, for the face
  u_char baselight;            // from 0xFF (dark) to 0 (bright)
  u_char light[2];             // two additional light models  
  long lightmap;               // Pointer inside the general light map, or -1
                               // this define the start of the face light map
} face_t;
</pre>

<p>The faces that lie in the same plane must be stored
consecutively, because they will be referenced as a list in the
definition of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLE" target="content">models</a>.</p>

<h4>Light level of the faces</h4>

<p>The <tt>lightmap</tt> field is an offset into the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL8">Light Maps</a>. If there is no light map, this pointer is
-1.</p>

<p>The <tt>baselight</tt> field gives the base light level for the
face, that is the minimum light level for the light map, or the
constant light level in the absence of light map.  Curiously, value
<tt>0xFF</tt> codes for minimum light, and value <tt>0</tt> codes for
maximum light.</p>

<p>The <tt>typelight</tt> field indicates the kind of lighting that
should be applied to the face:
</p><ul>
<li> value <tt>0</tt> is the normal value, to be used with a light
  map.
</li><li> value <tt>0xFF</tt> is to be used when there is no light map.
</li><li> value <tt>1</tt> produces a fast pulsating light
</li><li> value <tt>2</tt> produces a slow pulsating light
</li><li> value <tt>3</tt> to <tt>10</tt> produce various other
  lighting effects, as defined in <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_3.htm#PDAT" target="content">The code lump</a>.
</li></ul>
Note that if you use values <tt>1</tt> to <tt>8</tt>, you may wish to
set <tt>baselight</tt> to <em>0</em>.<p></p>



<h4>Texture mapping</h4>

<p>(Warning: texture mapping is totally different from early versions
of the BSP model. Forget about those early versions.)</p>

<p>To paint a face with a given texture, it is required that a position
<tt>(s,t)</tt> in texture space be associated to each vertex in 3D space.
</p>

<p>But that would make a lot of data, because a given vertex is often used
by more than one face, and each one require a special <tt>(s,t)</tt>
coordinate. So it has been prefered to store only the S and T vectors,
and to calculate the <tt>(s,t)</tt> coordinates on the fly, probably
when loading the level.</p>

<p>For a given face, the (s,t) coordinates are calculated from the 
<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL3" target="content">Vertex</a> coordinates and the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">Texture</a> 
definitions by a simple dot product with the S and T vectors:
</p><pre>s = dotproduct(Vertex,<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">vectorS</a>) + <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">distS</a>;    
t = dotproduct(Vertex,<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">vectorT</a>) + <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">distT</a>;
</pre>
<p></p>

<p>In theory, <tt>vectorS</tt> and <tt>vectorT</tt> should be orthogonal
vectors, and always lie in the face plane (or rather, the face plane),
so as to avoid any distortion when mapping the texture onto the face.</p>

<p>Actually, those two vectors are often chosen among the coordinate axis
themselves (or their opposite), so that textures in adjacent wall remain
naturally aligned, despite the possibly different orientation of the
walls. There is distortion of course, but it's limited.</p>

<p>Also, though the skies are ordinary wall textures, they are drawn in a 
very special way, that make them look like skies.  That is probably the 
same trick as in DOOM: it doesn't take the player position into account 
when texture mapping, only the orientation of view, so that the sky
appears to be far away.</p>




<h3>4.3.6 <a name="BL2">The Mip Textures</a></h3>

<p>The Mip textures definitions are used only in
<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">Texture info</a>, and are referenced by index, not by
name.</p>


<p>The Mip Texture definition is a structured file, that contains a list of
individual Mip Textures, each one accessed via an offset.
</p><pre>typedef struct                 // Mip texture list header
{ long numtex;                 // Number of textures in Mip Texture list
  long offset[numtex];         // Offset to each of the individual texture
} mipheader_t;                 //  from the beginning of mipheader_t
</pre><p></p>

<p>Each individual texture is also a structured entry, that indicates
the characteristics of the textures, and a pointer to scaled down
picture data.
</p><pre>typedef struct                 // Mip Texture
{ char   name[16];             // Name of the texture.
  u_long width;                // width of picture, must be a multiple of 8
  u_long height;               // height of picture, must be a multiple of 8
  u_long offset1;              // offset to u_char Pix[width   * height]
  u_long offset2;              // offset to u_char Pix[width/2 * height/2]
  u_long offset4;              // offset to u_char Pix[width/4 * height/4]
  u_long offset8;              // offset to u_char Pix[width/8 * height/8]
} miptex_t;
</pre><p></p>

<p>The Mip texture header is generally followed by <tt>(width *
height) * (85 / 64)</tt> bytes, that represent the color indexes of
the textures pixels, at different scales.  Do not rely on that size
however, rather consider the offsets described below.</p>

<p>The pixels are accessed by offsets, with <tt>offset1</tt>
(resp. <tt>2</tt>, <tt>3</tt>, <tt>4</tt>) pointing to the beginning
of the color indexes of the picture scaled by 1 (resp. 1/2, 1/4, 1/8).
These offsets are relative to the beginning of <tt>miptex_t</tt>.</p>

<p>The <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#CBSPI" target="content">name of the texture</a> is rather irrelevant,
except that:
</p><ul>
<li> if it begins by <tt>*</tt> it will be animated like lava or water.
</li><li> if it begins by <tt>+</tt> then it will be animated with frames,
     and the second letter of the name will be the frame number.
     Those numbers begin at 0, and go up to 9 at the maximum.
</li><li> if if begins with <tt>sky</tt> if will double scroll like a sky.<br>
     Beware that sky textures are made of two distinct parts.
</li></ul>
<p></p>

<p>An individual Mip texture occupies 33% more space than a simple
flat texture would.  This is the cost of anti-aliasing.</p>



<h3>4.3.7 <a name="BL0">The list of entities</a></h3>

<p>The format of the entity definitions is the same as in the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_2.htm#2.2.3" target="content">
Map specifications</a>, with the exception however that the entities that were
defined by brushes in the Map file are now defined as an index into the
<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLE" target="content">list of BSP models</a> that are part of the level BSP model.
</p>

<hr>

<h2><font color="#4F1F00">4.4 <a name="CBSPN">Bsp tree definition</a></font></h2>

<p>These are the entries that are related to the BSP tree that is used for rendering
the level.</p>

<h3>4.4.1 <a name="BL5">The BSP tree Nodes</a></h3>

<p>The BSP tree nodes are used to partition one model (from the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLE">List of models</a>) into a set of independent convex
<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">BSP tree Leaves</a>.</p>

<p>All the BSP tree nodes are stored in that same BSP tree node
structure, Though there is in fact one BSP tree per model.  But of
course no index should point to nodes that are part of another BSP
tree.</p>

<p></p><pre>typedef struct
{ long    plane_id;            // The <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL1" target="content">plane</a> that splits the node
                               //           must be in [0,numplanes[
  u_short front;               // If bit15==0, index of Front child node
                               // If bit15==1, <b>~front</b> = index of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">child leaf</a>
  u_short back;                // If bit15==0, id of Back child node
                               // If bit15==1, <b>~back</b> =  id of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">child leaf</a>
  bboxshort_t box;             // Bounding box of node and all childs
  u_short face_id;             // Index of first <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">Polygons</a> in the node
  u_short face_num;            // Number of faces in the node
} node_t;
</pre><p></p>

<h4>Organisation of the BSP tree</h4>

<p>The BSP tree nodes are part of a BSP tree, valid only inside a given model.</p>

<p>The <tt>front</tt> (resp. <tt>back</tt>) value is the equivalent of the
right (resp. left) of node, in DOOM.  Actually, even in DOOM it was the
front (resp. back) of a linedef, if it had been extended
vertically.</p>

<p>If the bit 15 is not set, as detected by <tt>(value &amp;
0x8000) == 0</tt>, then the number is the index to the front
(resp. back) child node.</p>

<p>If the bit 15 is set, then the child is in fact a BSP tree leaf,
and the index of this leaf is obtained by inverting all the bits of
<tt>front</tt> (resp. <tt>back</tt>).</p>

<p>In particular, the value -1 translates into leaf index 0. But
actually it means that there is no leaf. <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">Leaf 0</a>
is a dummy leaf, contains no faces, and has a special type (-2)
that means the BSP tree rendering must stop.</p>

<h4>The role of BSP tree nodes</h4>

<p>The nodes are the Quake equivalent of the DOOM nodes and also of
the DOOM blockmaps.  They are parts of a 3D BSP tree, not a 2D BSP
tree like in DOOM.</p>

<p>The nodes are used for level display, placements of entities and
second-level collision detections.</p>

<p>The front child node (and all the nodes below it) is entirely
contained in the half-space that is in front of the split plane.</p>

<p>The back child node (and all the nodes below it) is entirely
contained in the half-space that is in the back of the split plane.
(The 'front' and 'back' of a split planes are defined by the plane
equation giving a positive or negative result for any given
vertex.)</p>

<h4>The Bounding Boxes of nodes</h4>

<p>The Bounding box of the node is presented in a packed format,
bboxshort_t, that only contains short integer instead of floats.</p>

<p>That bounding box slightly exagerates the actual size of the node 
and all it's childs. Each bounding box boundary seems to be rounded to
the next multiple of 16, so that the bounding box is at least 32
units larger than it should be.</p>

<p>That means that the level coordinates must all remain roughly 
between -32700 and +32700.</p>

<h3>4.4.2 <a name="BLA">The BSP Tree Leaves</a></h3>

<p>The BSP tree leaves are children of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL5" target="content">BSP tree
Nodes</a> and indicate which <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">faces</a> are contained
inside a BSP tree leaf.</p>

<p></p><pre>typedef struct
{ long type;                   // Special type of leaf
  long vislist;                // Beginning of <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL4" target="content">visibility lists</a>
                               //     must be -1 or in [0,numvislist[
  bboxshort_t bound;           // Bounding box of the leaf
  u_short lface_id;            // First item of the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLB" target="content">list of faces</a>
                               //     must be in [0,numlfaces[
  u_short lface_num;           // Number of faces in the leaf  
  u_char sndwater;             // level of the four ambient sounds:
  u_char sndsky;               //   0    is no sound
  u_char sndslime;             //   0xFF is maximum volume
  u_char sndlava;              //
} dleaf_t;
</pre><p></p>

<p>The first leaf (index 0) is always totally solid, so that in the 
<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL5" target="content">BSP tree nodes</a>, a value of zero points to a solid
leaf (i.e. a leaf that need not be rendered).</p>

<p>The BSP tree leaf contains a reference to a set of consecutive
entries in the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLB" target="content">list of faces</a>.</p>

<p>The bounding box must contain all the faces in the leaf.</p>

<p>The leaf contains an index to the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL4" target="content">Visibility
Lists</a> that describe which other leaves are visible from that
leaf. If this index is -1, then all the other leaves are visible.</p>

<p>The tree leaves are the Quake equivalent of the sectors in DOOM.
You can imagine them as rooms, or part of rooms, where the monsters,
players and object will be placed.</p>

<p>Actually the tree leaves are the equivalent of the Sub Sectors:
each sector in DOOM is decomposed by the BSP into smaller and simpler
convex sub sectors, that contain only part of the sector lines.</p>

<p>Technically, each tree leaf, made of some faces and bound by the
BSP node split lines, appears in 3D space as a convex polytope.</p>

<h4>Leaf types</h4>

<p>The <tt>type</tt> field describes what happens when the player
is into that precise leaf. Here are the known values (negative):
</p><ul>
<li> <b>-1</b>: ordinary leaf
</li><li> <b>-2</b>: the leaf is entirely inside a solid (nothing is displayed).
</li><li> <b>-3</b>: Water, the vision is troubled.
</li><li> <b>-4</b>: Slime, green acid that hurts the player.
</li><li> <b>-5</b>: Lava, vision turns red and the player is badly hurt.
</li><li> <b>-6</b>: Behaves like water, but is used for sky.
</li><li> All types below -6 seem to be water (maybe they are not
  implemented yet)
</li></ul>
Note that this field is only taken into account when the player is in
the leaf, so if you're in a leaf full of water you'll see the world
blurred, but players outside will see you perfectly.  <p></p>



<h3>4.4.3 <a name="BLB">The List of Faces</a></h3>

<p>This structure stores a list of indexes of faces, so that a list
of faces can be conveniently associated to each <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">BSP
tree leaf</a>.</p>

<p></p><pre>u_short lface[numlface];   // each u_short is the index of a <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">Face</a>
</pre><p></p>

<p>The list of faces is only used by the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">BSP tree
leaf</a>.  This intermediary structure was made necessary because the
<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">faces</a> are already referenced by <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL5">Nodes</a>, so a simple reference by first face and
number of faces was not possible.</p>




<h3>4.4.4 <a name="BLD">The List of Edges</a></h3>

<p>This structure stores indexes of edges, possibly inverted, so that
<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">faces</a> can be reconstituted.</p>

<p></p><pre>short lstedge[numlstedge];
</pre><p></p>

<p>All the edges in a <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">face</a> are stored
consecutively, with the correct orientation so that all the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL3">vertices</a> in the face are walked
<b>clockwise</b>.</p>

<p>But since the edges are used for more than one face, there is a
trick to ensure that the edge of a given face is always referenced
with the correct orientation:
</p><ul>
<li> if <tt>lstedge[e]</tt> is positive, then <tt>lstedge[e]</tt> is
  an index to an <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLC" target="content">Edge</a>, and that edge is walked in the
  normal sense, from vertex0 to vertex1.
</li><li> if <tt>lstedge[e]</tt> is negative, then <tt>-lstedge[e]</tt> is
  an index to an <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLC" target="content">Edge</a>, and that edge is walked in the
  inverse sense, from vertex1 to vertex0.
</li></ul><p></p>

<p>The fact that all edges are walked in a <b>clockwise</b> order is
<b>critical</b> for the face rendering process (rasterisation).</p>

<p>The faces are made of just one closed set of edges, or
contour. Those edges seem to be always stored in the right order.</p>





<h3>4.4.5 <a name="BL4">Visibility Lists</a></h3>

<p><i>(Thanks to David Etherton for determining the precise formula)</i></p>

<p>The visibility lists are used by <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">BSP Leaves</a>, to
determine which other leaves are visible from a given BSP Leaf.</p>

<p>The Visibility list can be of size 0, in that case it will not be
used.  The game will crawl if there is no visibility list in a
level.</p>

<p></p><pre>u_char vislist[numvislist];    // RLE encoded bit array
</pre><p></p>


<p>Basically, the visibility list is an array of bits. There is one
such array of bits for each <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA" target="content">BSP Leaf</a>.  They are all
stored in the vislist array, and each leaf has an index to the first
byte of it's own array</p>

<p>The bit number N, if set to 1, tells that when laying in the tree
leaf, one can see the leaf number N.</p>

<p>The only complication is that this bit array in run-length encoded:
when a set of bytes in the array are all zero, they are coded by zero
followed by the number of bytes is the set (always more than 1).</p><p>

</p><p>Normally, the size of the bit array associated to a leaf should be
<tt>(<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLE" target="content">numleafs</a>+7)/8</tt>, but in fact due to the run
lenght encoding, it's usually much less.</p>

<p>When the player is in a leaf, the visibility list is used to tag
all the leaves that can possibly be visible, and then only those
leaves are rendered.</p>

<p>Here is an example of decoding of visibility lists:
<code></code></p><pre><code>// Suppose Leaf is the leaf the player is in.
v = Leaf.vislist;
for (L = 1; L &lt; numleaves; v++)
  {
    if (visisz[v] == 0)           // value 0, leaves invisible
      {
        L += 8 * visisz[v + 1]    // skip some leaves
        v++;
      }
    else                          // tag 8 leaves, if needed
      {                           // examine bits right to left
        for (bit = 1; bit != 0; bit = bit * 2, L++)
          {
            if (visisz[v] &amp; bit)
              TagLeafAsVisible(L);
          }
      }
  }
</code></pre>
Lots of thanks to <b>Tony Myles</b> who fixed the  bit mask formula.
<p></p>

<p>There is no necessity to unpack the visibility list in memory,
because the code to read them is fast enough.</p>

<p>If you put a few badly placed zero bits in the visibility lists,
some of the leaves will turn into totally grey areas, and that's
rather funny.  If you put <b>all bits to zero</b> for a given <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLA">leaf</a>, then every player in that sector will become
temporarily <b>blind</b>: he will get a fully grey screen.  I wonder
what use you can make of this in level design, though.  If only it had
been black...</p>

<p>The visibility list structure is the Quake equivalent of the REJECT
map of DOOM, except that now it's also <b>used for level
rendering</b>.  It eliminates leaves that can't be seen, whereas in
DOOM it was just use to speed up monster line of sight
calculations.</p>



<hr>

<h2><font color="#4F1F00">4.5 <a name="CBSPC">Pre-calculated geometric
entries</a></font></h2>

<p>Those entries can all be automatically calculated from the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#CBSPL">Level layout definition</a>, and are not related to the
<a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#CBSPN" target="content">Bsp tree definition</a>.</p>

<p>Do not confuse the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL9">Clip Nodes</a> with the BSP
tree nodes, they are not used for the rendering of the level.</p>

<h3>4.5.1 <a name="BL1">List of Planes</a></h3>

<p>The plane definitions are used for <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content">faces</a>, <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL5">BSP Nodes</a>, <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL9" target="content">Clip Nodes</a>.</p>

<p>The order of planes in list is irrelevant.
</p><pre>typedef struct
{ vec3_t normal;               // Vector orthogonal to plane (Nx,Ny,Nz)
                               // with Nx2+Ny2+Nz2 = 1
  scalar_t dist;               // Offset to plane, along the normal vector.
                               // Distance from (0,0,0) to the plane
  long    type;                // Type of plane, depending on normal vector.
} plane_t;
</pre><p></p>
     
<p>Plane <tt>type</tt>s:
</p><ul> 
<li> 0:  Axial plane, in X
</li><li> 1:  Axial plane, in Y
</li><li> 2:  Axial plane, in Z
</li><li> 3:  Non axial plane, roughly toward X
</li><li> 4:  Non axial plane, roughly toward Y
</li><li> 5:  Non axial plane, roughly toward Z
</li></ul>
<p></p>

<p>The planes are used as split planes in the BSP tree nodes, and as
reference plane in the faces.</p>

<p>They are the Quake equivalent of the DOOM Linedefs and
Segments.</p>

<p>The planes are defined by a normal vector and a distance.  This
normal vector must be of norm 1.</p>

<p>The plane equations are used for distance calculation and to
determine if a given vertex (of a face, or an entity) is on the
front side or the back side of the plane.</p>

<p>Some of the planes, especially the first ones in the list, are not
associated to any face, but rather to BSP nodes split planes.  So
they show <tt>numsurf = 0</tt>.</p>

<p>There must be only one given plane definition, for any plane in 3D
space.  That's because the calculations of the translation and
rotation of plane normal vector are cached, so if you put redundant
planes definitions you'll contribute to slowing down the engine.
Definitely not an option.</p>



<h3>4.5.2 <a name="BL9">The Clip Nodes</a></h3>

<p>This structure is used to give a rough and somewhat exaggerated
boundary to a given <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLE" target="content">model</a>.  It does not separate
models from each others, and is not used at all in the rendering of the
levels</p>

<p>Actually, the clip nodes are only used as a first and primitive
collision checking method. </p>

<p>The clip nodes are much simpler than the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL5" target="content">BSP
nodes</a>, so it makes collision detection faster, most of the time.
In the same idea, DOOM defined a BLOCKMAP for faster collision
detection.</p>

<p></p><pre>typedef struct
{ u_long planenum;             // The <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL1" target="content">plane</a> which splits the node
  short front;                 // If positive, id of Front child node
                               // If -2, the Front part is inside the model
                               // If -1, the Front part is outside the model
  short back;                  // If positive, id of Back child node
                               // If -2, the Back part is inside the model
                               // If -1, the Back part is outside the model
} clipnode_t;
</pre><p></p>

<p>The engine starts from the top bound node as defined in the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLE">Model</a>.
</p><ul>

<li>If the value of <tt>front</tt> (resp. <tt>back</tt>) is positive,
  then it's the index of a child clip node.
</li><li>If value <tt>-1</tt> is met, then the front (resp. back) half
  space is outside of the model, and collision is impossible.
</li><li> If the value <tt>-2</tt> is met, then the front (resp. back) half
  space is inside the model, and the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL5" target="content">BSP nodes</a> must be
  checked.
</li></ul>
<p></p>

<p>There is no bounding box defined for those nodes, because the
bounding box is that of the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLE" target="content">model</a> bounding
boxes.</p>

<p>If you modify a clip node, for instance by changing the plane
definitions or by putting -1 values for each child, then the model
becomes totally pass-through.  That's a very funny special effect.</p>

<p>The Clip Nodes do not tightly bound a model, so you should
<em>never</em> use planes from the model as clip node split
planes. Actually, the clip node planes should be distant from the
model by at least <em>16</em> in X,Y, and <em>24</em> in Z.</p>

<p>Also take care that the Clip Node planes should be oriented toward
the <em>exterior</em> of the model, not the interior.  If you change
the orientation, then the player can go through the model as if it did
now exist... even falling through the floor.</p>




<h3>4.5.3 <a name="BL8">The Light Maps</a></h3>

<p>The light maps are special arrays that indicate the brightness of
some points in the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL2" target="content">Mip Texture</a> pictures.</p>

<p>Different light maps can be associated to each <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7">face</a>, so that two faces with similar textures
can still look different, depending on the light level.</p>

<p>The light maps are simply:
</p><pre>u_char lightmap[numlightmap];  // value <b>0</b>:dark <b>255</b>:bright
</pre><p></p>

<h4>Light levels</h4>

<p>The u_char value that the lightmap gives at any point is directly a
light level value, from 0 to 255.  If you put zero, it will be utter
darkness, and if you put 255 if will be totally bright.</p>

<p>The formula for calculating light level is something like:
</p><pre>light(X,Y,Z) = lightmap(X,Y,Z) * lightstyle(typelight, time) - baselight
</pre>
where, as a rough explanation:
<ul>
<li> <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7" target="content"><tt>baselight</tt></a> is the base light level of
  each face (the flat shading of the surface).
</li><li> <tt>lightmap(X,Y,Z)</tt> results from the translation of the
  lightmap into 3D space (see below).
</li><li> <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_3.htm#PDAT" target="content"><tt>lightstyle</tt></a> is a table of available
  light styles, available in the code lump. The light style used depends
  on the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">typelight</a> of the corresponding face.
</li><li> The exact lightstyle multiplier changes over time, so that it
  looks like the face's light is pulsating.
</li></ul>
<p></p>

<p>Note that the textures's color and light are translated into a
final color by using a pre-calculated color palette.  Direct RGB
calculations would be too costly and not very suitable for 256 color
displays.  This is the same trick as used when gouraud shading the
Alias models.</p>



<h4>Translation of lightmaps into 3D space</h4>

<p>Well the exact formula seems rather hard to determine
experimentally, so don't expect this explanation to be accurate.</p>

<p>The size and layout of a lightmap, on texture space, is not related
to the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL2">texture</a> but only to the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7">face</a> extent, in 3D space. You can change the
texture without having to recalculate light maps.</p>

<p>Each light maps seem to be stored as a simple
</p><pre>u_char light[width*height];
</pre>
where <tt>width</tt> and <tt>height</tt> are determined by the extents
of the faces's bounding box, i.e. the bounding box of all the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL3">vertices</a> contained in that face (or, rather, all
the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLC" target="content">Edges</a>).<p></p>

<p>Since such a bounding box is essentially 3D, and the lightmap is
only 2D, one coordinate has to be discarded. The coordinate to remove
depends on the orientation of the face's plane, as given by the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL1">Plane Type</a>.</p>

<p>This mapping from 3D to 2D, by discarding one coordinate, is
exactly the same as the one used for <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL6" target="content">Texture
Mapping</a> the faces.  You can probably consider the lightmaps as
``alpha-channel textures'' which modify the intensity of the real
textures on which they are applied.</p>

<p>Note that the extents of the bounding box (i.e. the difference
between maximum and minimum values) must be divided by 16 to give the
<tt>width</tt> and <tt>height</tt>, because a lightmap value is only
calculated every 16 steps, for every coordinate.

</p><p>Calculating only every 16 steps make the radiosity calculation 256
times less tedious, and ensures that the lightmap will look nice and
smooth on the face (because bilinear interpolation is used between
known lightmap values).</p>


<h4>Unknown Fields</h4>

<p>I'm aware that the above explanation is rather obfuscated, and may
not cover all cases.  It's savagely hacked out of some experimental
results and some considerations on the convenience of
calculations.</p>

<p>Note also that the lightmap are oriented in regard to the 3D
coordinates, and do not seem to care about the face orientation.
So if you modify a lightmap, chances are that your modifications will
happen is some unexpected place (like, at the bottom instead of at the
top...).</p>

<p>Last, in case you wonder where the <tt>lightstyle</tt> table is
defined, the answer is: no idea. </p>

<hr>

<h2><font color="#4F1F00">4.6 <a name="CBSPI">Additional Informations</a></font></h2>


<h3>4.6.1 Texture names</h3>

<p><i>(Thanks to Stephen Crowley for experimenting with the names)</i></p>

<p>The names of textures can contain up to 16 characters.</p>

<p>The animation of the texture is entirely determined by it's name:
there are three special names, that make different animations. All the
other names mean that the texture is not animated.</p>

<p>Here are the animated textures:
</p><ul>
<li> <b>sky</b>: the texture will behave like a sky, with two levels
        of scrolling made of two parts of the textures.
</li><li> <b>*lava</b>: the texture slowly swirls, like the lava.
</li><li> <b>*water</b>: the texture lsowly swirls, apparently like lava. 
</li></ul>
Currently, no other combination works.
<p></p>


<p>When displaying an animated texture, the lightmap and light levels
are not taken into account. Those textures are always rendered at full
brightness, probably because the face cache would be saturated if
every animation frame had to fit into it.</p>

<p>Note that sky textures have an extent that make them too big to
display as an ordinary wall texture, and that if you turn an ordinary
texture into a sky texture, it will look fairly weird.</p>

<p>Also, for some strange reason, bit <tt>4</tt> of the <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BL7">face flags</a> is set when the texture is supposed to
be animated. If you replace an animated texture by an ordinary texture,
and forget to set this bit to zero, then there will be an error like:
<tt>SurfExtent&gt;256</tt>.</p>



<h3>4.6.2 Texture Anti-aliasing</h3>


<p>This is an attempted explanation for the curious structure of the
Mip Texture.</p>

<p>The sampling theorem states that when you sample any signal (sound,
picture, anything) the highest frequency contained in this signal must
be at most one half of the sampling frequency.  If there is any
frequency above that, the sampling process will map it into a lower
frequency, thus creating a terrible mess into the sampled signal.
This mess is called Aliasing.</p>

<p>When you try to display a picture on a smaller space, you increase
all the frequencies contained in that picture, and thus risk Aliasing.
That's basically what happened in DOOM at long distance.</p>

<p>Now, all you need is only to low-pass filter the picture, with a
cut frequency equal to half the sampling frequency.  Easy!  But...
There is no DSP on the video memory, so those calculations would take
too much time.  It's much easier to pre-calculate 4 scaled down
pictures, that can be used across the most common range of scales:<br>
infinity-1, 1-1/2, 1/2-1/4, 1/4-1/8.<br>
Below 1/8, there will be some aliasing...</p>





<hr size="3">
</body></html>